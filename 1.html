<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Made with hands</title>
  
  <link rel="stylesheet" href="qunit-1.23.1.css">
  <script src="qunit-1.23.1.js"></script>
  <script>
  	var testlib = QUnit;
  </script>
  
  <script src="plastiq/plastiq.js"></script>
  <script src="plastiq.js"></script>
  <script src="140medley.js"></script>
  
  <script src="graph.js"></script>
  <script src="graph-tests.js"></script>
  <script>
	var h = plastiq.html;
	var bind = plastiq.bind;
    var refresh = plastiq.html.refresh;

	function partial(fn /*, args...*/) {
		// A reference to the Array#slice method.
		var slice = Array.prototype.slice;
		// Convert arguments object to an array, removing the first argument.
		var args = slice.call(arguments, 1);

		return function() {
			// Invoke the originally-specified function, passing in all originally-
			// specified arguments, followed by any just-specified arguments.
			return fn.apply(this, args.concat(slice.call(arguments, 0)));
		};
 	}

	//function newCC(component) {
	//	var componentContainer = { _instances: new Array() };
	//	componentContainer._function = partial(component, componentContainer._instances);
	//	return componentContainer;
	//}

	//function useCC(componentContainer) {
	//	var component = h.component(componentContainer._function);
	//	componentContainer._instances.push(component);
	//	return component;
	//}

	//function democomp(instances, model) {
	//	return h('button', {onclick: function () { 
	//				model.counter++;
	//				return instances; 
	//			}}, 'refresh components');
	//}


	function hashSetHasKey(hashSet, key) {
		return hashSet.hasOwnProperty(key);
	}
	
	function renderTriples(model) {
		return renderLevel(model, 0);
	}
	function renderLevel(model, depth) {

		return h('div', model.graph._graph.map(function (triple) {
			return h('div',
				renderLevelPosition(model, new GraphNode(triple, 's')), ' ',
				renderLevelPosition(model, new GraphNode(triple, 'p')), ' ',
				renderLevelPosition(model, new GraphNode(triple, 'o'))
				);
		}));
	}
	function renderLevelPosition(model, graphNode) {
        return entityController(model, graphNode);   
	}
	function entityController(model, graphNode) {
        var controllerEventHandler = function (handler, model, graphNode, e) {
            return function (e) {
                if (partial(handler, model, graphNode).apply(this, arguments)) {
                    if (e.preventDefault) {
                        e.preventDefault();
                    } else {
                        e.returnValue = false;
                    }
                }
            }
        }
		var style = {};
		if (model.meta.currentNode && model.meta.currentNode.getValue() == graphNode.getValue()) {
			style.color = 'red';
		}
		return h('span', {
				style: style,
				tabIndex: 0,
				onkeydown: controllerEventHandler(controllerKeydown, model, graphNode),
				onclick: controllerEventHandler(controllerClick, model, graphNode),
                onfocus: partial(refreshMeta, model, graphNode)
			}, graphNode.getValue());
	}
    
    function refreshMeta(model, graphNode) {
        if (!graphNode) { return; }
        if (model.meta.currentNode) {
            if (model.meta.currentNode.getValue() != graphNode.getValue()) {
                model.meta.previousNode = model.meta.currentNode;
                if (model.meta.previousNode.position != 'p') {
                    model.meta.previousNodeNonPredicate = model.meta.previousNode
                } else {
                    model.meta.previousNodePredicate = model.meta.previousNode
                }
                model.meta.currentNode = graphNode;
            }
        } else {
            model.meta.currentNode = graphNode;
        }
    }
    
    function controllerClick(model, graphNode, e) { 
        //triple[position] = triple[position] + 'a';
        model.graph.replaceNode(graphNode, graphNode.getValue() + 'a');
        refreshMeta(model, graphNode);
        return true;
    }
    
    function controllerKeydown(model, graphNode, e) {
        $('#t').textContent = e.keyCode + ' ' + e.key;
        refreshMeta(model, graphNode);
        return !(e.keyCode == 9);
    }

	function renderLevelPositionSimple(entity, componentContainerDict) {
		return h('div', entity);
	}

	var graph = new Graph();
	graph.addTriple(Graph.makeTriple("testS", "testP", "testO"));
	graph.addTriple(Graph.makeTriple("testS", "testP2", "testO"));
	graph.addTriple(Graph.makeTriple("testO", "testP3", "testO3"));

	//var defaultTriples = [ { s: "testS", p: "testP", o: "testO" }, { s: "testS", p: "testP2", o: "testO" }, { s: "testO", p: "testP3", o: "testO3" } ];

	var k = function (e) {
	  $('#t').textContent = e.keyCode;
      e.preventDefault();
	  return false;
	};
    window.onload = function () {
		//$('#h').onkeydown = k;
	
		//plastiq.append(document.body, render, {name: '', m2: {counter: 0}, counter2: 0});
		var model0 = { graph: graph, // defaultTriples, 
		  	meta: { currentNode: null, previousNode: null, 
              previousNodeNonPredicate: null, previousNodePredicate: null } };
		plastiq.append($('#plastiq'), function (model) { return renderTriples(model); }, model0);

		setInterval(function() { $('#graph').textContent = JSON.stringify(model0); }, 1000);
    };
  </script>
</head>
<body>

  <h1 id="h">Semaea</h1>
  <p>
    asd
  </p>

  <textarea id="t" tabindex="-1" disabled="disabled">asdasda</textarea>

  <p id="graph">graph<p>
	  
  <p id="plastiq"></p>

  <div id="qunit"></div>
  <div id="qunit-fixture"></div>
</body>
</html>

